<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Engine Studio - Master Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: grid;
            grid-template-columns: 250px 1fr;
            grid-template-rows: 60px 1fr;
            height: 100vh;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: #0d0d0d;
            border-bottom: 2px solid #00a8ff;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 100;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            flex: 1;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0000;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #00ff00;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        /* Sidebar */
        .sidebar {
            background: #1f1f1f;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 16px;
        }

        .nav-section {
            margin-bottom: 24px;
        }

        .nav-section-title {
            font-size: 11px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .nav-item {
            padding: 10px 12px;
            margin-bottom: 6px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            color: #aaa;
        }

        .nav-item:hover {
            background: rgba(0, 168, 255, 0.1);
            color: #00a8ff;
        }

        .nav-item.active {
            background: rgba(0, 168, 255, 0.2);
            border-color: #00a8ff;
            color: #00a8ff;
        }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-rows: 1fr auto;
            overflow: hidden;
        }

        .workspace {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 10px;
            padding: 10px;
            overflow: hidden;
        }

        .panel {
            background: #252525;
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1f1f1f;
        }

        .panel-header h2 {
            font-size: 14px;
            font-weight: 600;
        }

        .panel-content {
            flex: 1;
            overflow: auto;
            padding: 12px 16px;
        }

        /* Canvas Panel */
        #canvas-container {
            background: #1a1a1a;
            position: relative;
            overflow: auto;
        }

        canvas {
            display: block;
            background: linear-gradient(135deg, #1a1a1a 0%, #252525 100%);
        }

        /* Control Panel */
        .control-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 12px;
            background: #1f1f1f;
            border-top: 1px solid #333;
        }

        button {
            padding: 8px 12px;
            background: #00a8ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }

        button:hover {
            background: #0088cc;
        }

        button:active {
            transform: scale(0.98);
        }

        button.secondary {
            background: #444;
            color: #ccc;
        }

        button.secondary:hover {
            background: #555;
        }

        button.danger {
            background: #ff4444;
        }

        button.danger:hover {
            background: #cc0000;
        }

        /* Metrics Panel */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .metric {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #00a8ff;
        }

        .metric-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }

        .metric-value {
            font-size: 20px;
            font-weight: 700;
            color: #00ff00;
            margin-top: 4px;
            font-family: 'Courier New', monospace;
        }

        /* Entity List */
        .entity-item {
            background: #1a1a1a;
            padding: 8px;
            margin-bottom: 6px;
            border-radius: 3px;
            border-left: 3px solid #00a8ff;
            font-size: 12px;
        }

        .entity-label {
            font-weight: 600;
            color: #00ff00;
        }

        .entity-value {
            color: #aaa;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        /* Terminal */
        .terminal-panel {
            background: #0a0a0a;
            border-top: 2px solid #00a8ff;
            font-family: 'Courier New', monospace;
        }

        #terminal {
            height: 150px;
            overflow-y: auto;
            padding: 12px;
            font-size: 12px;
            line-height: 1.5;
        }

        .terminal-line {
            margin-bottom: 4px;
        }

        .terminal-prompt {
            color: #00ff00;
        }

        .terminal-output {
            color: #aaa;
        }

        .terminal-error {
            color: #ff4444;
        }

        .terminal-input-area {
            display: flex;
            border-top: 1px solid #333;
            padding: 8px 12px;
            gap: 8px;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: 1px solid #333;
            border-radius: 3px;
            padding: 6px 8px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .terminal-input:focus {
            outline: none;
            border-color: #00a8ff;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Hidden Panels */
        .panel { display: none; }
        .panel.active { display: flex; }

        /* Responsive */
        @media (max-width: 1200px) {
            .workspace {
                grid-template-columns: 1fr;
            }

            .sidebar {
                max-height: 200px;
                border-bottom: 1px solid #333;
                border-right: none;
            }

            .app-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <h1>‚öôÔ∏è World Engine Studio</h1>
            <div class="api-status">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Disconnected</span>
            </div>
        </div>

        <!-- Sidebar Navigation -->
        <div class="sidebar">
            <div class="nav-section">
                <div class="nav-section-title">Workspace</div>
                <button class="nav-item active" onclick="switchPanel('canvas')">üìä Node Graph</button>
                <button class="nav-item" onclick="switchPanel('physics')">‚ö° Physics Engine</button>
                <button class="nav-item" onclick="switchPanel('metrics')">üìà Metrics</button>
                <button class="nav-item" onclick="switchPanel('entities')">üî∑ Entities</button>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Systems</div>
                <button class="nav-item" onclick="switchPanel('prophecy')">üîÆ Keeper Nexus</button>
                <button class="nav-item" onclick="switchPanel('geometry')">üé® Geometry</button>
                <button class="nav-item" onclick="switchPanel('aesthetics')">‚ú® Aesthetics</button>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Tools</div>
                <button class="nav-item" onclick="switchPanel('terminal')">üíª Terminal</button>
                <button class="nav-item" onclick="showAbout()">‚ÑπÔ∏è About</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <div class="workspace">
                <!-- Canvas Panel -->
                <div class="panel active" id="canvas-panel">
                    <div class="panel-header">
                        <h2>Node Graph Canvas</h2>
                        <button class="secondary" style="padding: 4px 8px; font-size: 10px;" onclick="resetCanvas()">Reset View</button>
                    </div>
                    <div class="panel-content" id="canvas-container">
                        <canvas id="nodeCanvas"></canvas>
                    </div>
                </div>

                <!-- Physics Panel -->
                <div class="panel" id="physics-panel">
                    <div class="panel-header">
                        <h2>Physics Engine</h2>
                    </div>
                    <div class="panel-content">
                        <div class="control-panel">
                            <button onclick="spawnPhysicsBody()">Spawn Body</button>
                            <button id="stepBtn" onclick="stepPhysics()">Step</button>
                            <button id="autoStepBtn" onclick="toggleAutoStep()" class="secondary">Auto Step</button>
                        </div>
                        <div id="physicsStatus" style="margin-top: 12px; color: #aaa; font-size: 12px;">
                            <p>Physics Status: <span id="physicsState">Disconnected</span></p>
                        </div>
                    </div>
                </div>

                <!-- Metrics Panel -->
                <div class="panel" id="metrics-panel">
                    <div class="panel-header">
                        <h2>Real-Time Metrics</h2>
                    </div>
                    <div class="panel-content">
                        <div class="metrics-grid">
                            <div class="metric">
                                <div class="metric-label">Frame</div>
                                <div class="metric-value" id="frameCount">0</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">KE (J)</div>
                                <div class="metric-value" id="kineticEnergy">0.0</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Bodies</div>
                                <div class="metric-value" id="bodyCount">0</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Collisions</div>
                                <div class="metric-value" id="collisionCount">0</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">FPS</div>
                                <div class="metric-value" id="fpsValue">60</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Time (s)</div>
                                <div class="metric-value" id="simTime">0.00</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Entities Panel -->
                <div class="panel" id="entities-panel">
                    <div class="panel-header">
                        <h2>Active Entities</h2>
                    </div>
                    <div class="panel-content" id="entitiesList">
                        <p style="color: #666;">No active entities</p>
                    </div>
                </div>

                <!-- Prophecy Panel -->
                <div class="panel" id="prophecy-panel">
                    <div class="panel-header">
                        <h2>Keeper Nexus Prophecies</h2>
                    </div>
                    <div class="panel-content">
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 6px; font-size: 12px;">Apply Prophecy:</label>
                            <input type="text" id="prophecyInput" placeholder="e.g., apply_force_y:10" 
                                   style="width: 100%; padding: 6px; border: 1px solid #333; border-radius: 3px; 
                                          background: #1a1a1a; color: #00ff00; font-family: monospace; font-size: 11px;">
                            <button onclick="applyProphecy()" style="width: 100%; margin-top: 8px;">Apply</button>
                        </div>
                        <div id="prophecyLog" style="font-size: 11px; color: #888;">
                            <p>Prophecies will appear here...</p>
                        </div>
                    </div>
                </div>

                <!-- Geometry Panel -->
                <div class="panel" id="geometry-panel">
                    <div class="panel-header">
                        <h2>Geometry (Surface Nets)</h2>
                    </div>
                    <div class="panel-content">
                        <p style="color: #aaa; font-size: 12px;">Surface mesh generation from physics deformation</p>
                        <button onclick="generateSurfaceNets()" style="width: 100%; margin-top: 12px;">Generate Mesh</button>
                        <div id="geometryStatus" style="margin-top: 12px; color: #888; font-size: 11px;">
                            <p>Mesh status: Idle</p>
                        </div>
                    </div>
                </div>

                <!-- Aesthetics Panel -->
                <div class="panel" id="aesthetics-panel">
                    <div class="panel-header">
                        <h2>Aesthetic Pathway</h2>
                    </div>
                    <div class="panel-content">
                        <p style="color: #aaa; font-size: 12px;">Visual feedback generation from physics state</p>
                        <button onclick="updateAesthetics()" style="width: 100%; margin-top: 12px;">Update Visuals</button>
                        <div id="aestheticsStatus" style="margin-top: 12px; color: #888; font-size: 11px;">
                            <p>Aesthetic status: Idle</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Terminal -->
            <div class="terminal-panel" id="terminal-panel">
                <div id="terminal"></div>
                <div class="terminal-input-area">
                    <span class="terminal-prompt">></span>
                    <input type="text" id="terminalInput" class="terminal-input" placeholder="Enter command..." 
                           onkeypress="handleTerminalInput(event)">
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CORE STATE MANAGEMENT
        // ============================================
        const state = {
            apiConnected: false,
            autoStepping: false,
            physicsState: null,
            entities: [],
            prophecyLog: [],
            selectedEntity: null,
            canvas: null,
            canvasCtx: null,
            lastFrameTime: Date.now(),
            fps: 60
        };

        const API_URL = 'http://localhost:8001';
        const CANVAS_SCALE = 30; // pixels per physics unit

        // ============================================
        // INITIALIZATION
        // ============================================
        window.addEventListener('DOMContentLoaded', () => {
            initializeCanvas();
            checkAPIConnection();
            setInterval(checkAPIConnection, 5000);
            setInterval(updateMetrics, 100);
            setInterval(renderCanvas, 1000 / 60); // 60 FPS
        });

        function initializeCanvas() {
            state.canvas = document.getElementById('nodeCanvas');
            state.canvasCtx = state.canvas.getContext('2d');
            
            const container = document.getElementById('canvas-container');
            state.canvas.width = container.clientWidth;
            state.canvas.height = container.clientHeight;

            window.addEventListener('resize', () => {
                if (container.parentElement.parentElement.classList.contains('active')) {
                    state.canvas.width = container.clientWidth;
                    state.canvas.height = container.clientHeight;
                }
            });
        }

        // ============================================
        // API COMMUNICATION
        // ============================================
        async function checkAPIConnection() {
            try {
                const response = await fetch(\`\${API_URL}/health\`, { 
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                if (response.ok) {
                    state.apiConnected = true;
                    document.getElementById('statusIndicator').classList.add('connected');
                    document.getElementById('statusText').textContent = 'Connected';
                    await fetchPhysicsState();
                } else {
                    setDisconnected();
                }
            } catch (e) {
                setDisconnected();
            }
        }

        function setDisconnected() {
            state.apiConnected = false;
            document.getElementById('statusIndicator').classList.remove('connected');
            document.getElementById('statusText').textContent = 'Disconnected';
            document.getElementById('physicsState').textContent = 'Offline (Mock Mode)';
        }

        async function fetchPhysicsState() {
            if (!state.apiConnected) return;
            try {
                const response = await fetch(\`\${API_URL}/physics/state\`);
                if (response.ok) {
                    state.physicsState = await response.json();
                    await fetchEntities();
                }
            } catch (e) {
                console.warn('Physics state fetch failed:', e);
            }
        }

        async function fetchEntities() {
            if (!state.apiConnected) return;
            try {
                const response = await fetch(\`\${API_URL}/physics/entities\`);
                if (response.ok) {
                    state.entities = await response.json();
                    updateEntitiesList();
                }
            } catch (e) {
                console.warn('Entities fetch failed:', e);
            }
        }

        async function spawnPhysicsBody() {
            if (!state.apiConnected) {
                logTerminal('Physics API not connected', 'error');
                return;
            }

            const x = Math.random() * 10 - 5;
            const y = Math.random() * 5 + 5;
            const z = 0;

            try {
                const response = await fetch(\`\${API_URL}/physics/spawn\`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        position: [x, y, z],
                        velocity: [0, 0, 0],
                        mass: 1.0,
                        radius: 0.5,
                        is_static: false,
                        restitution: 0.6,
                        label: \`Body_\${Date.now()}\`
                    })
                });

                if (response.ok) {
                    const body = await response.json();
                    logTerminal(\`Spawned body: \${body.label} at (\${x.toFixed(2)}, \${y.toFixed(2)}, \${z})\`, 'output');
                    await fetchEntities();
                } else {
                    logTerminal('Failed to spawn body', 'error');
                }
            } catch (e) {
                logTerminal(\`Error: \${e.message}\`, 'error');
            }
        }

        async function stepPhysics() {
            if (!state.apiConnected) {
                logTerminal('Physics API not connected', 'error');
                return;
            }

            try {
                const response = await fetch(\`\${API_URL}/physics/step\`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (response.ok) {
                    await fetchPhysicsState();
                    logTerminal('Physics stepped', 'output');
                }
            } catch (e) {
                logTerminal(\`Step error: \${e.message}\`, 'error');
            }
        }

        async function resetPhysics() {
            if (!state.apiConnected) return;

            try {
                await fetch(\`\${API_URL}/physics/reset\`, { method: 'POST' });
                state.entities = [];
                state.physicsState = null;
                updateEntitiesList();
                logTerminal('Physics reset', 'output');
            } catch (e) {
                logTerminal(\`Reset error: \${e.message}\`, 'error');
            }
        }

        // ============================================
        // UI OPERATIONS
        // ============================================
        function switchPanel(panelName) {
            // Hide all panels
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            
            // Show selected panel
            const panelId = panelName + '-panel';
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.classList.add('active');
                logTerminal(\`Switched to \${panelName} panel\`, 'output');
            }

            // Update nav items
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            event.target.classList.add('active');
        }

        function toggleAutoStep() {
            state.autoStepping = !state.autoStepping;
            const btn = document.getElementById('autoStepBtn');
            btn.textContent = state.autoStepping ? '‚è∏ Pause' : '‚ñ∂ Auto Step';
            
            if (state.autoStepping) {
                setInterval(() => {
                    if (state.autoStepping) stepPhysics();
                }, 33); // ~30 FPS
            }
        }

        // ============================================
        // VISUALIZATION
        // ============================================
        function renderCanvas() {
            const canvas = state.canvas;
            const ctx = state.canvasCtx;

            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += CANVAS_SCALE * 2) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += CANVAS_SCALE * 2) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw entities
            if (state.entities && state.entities.length > 0) {
                state.entities.forEach((entity, idx) => {
                    const x = canvas.width / 2 + (entity.position ? entity.position[0] * CANVAS_SCALE : 0);
                    const y = canvas.height / 2 - (entity.position ? entity.position[1] * CANVAS_SCALE : 0);
                    const radius = (entity.radius || 0.5) * CANVAS_SCALE;

                    // Body
                    const energy = entity.kinetic_energy || 0;
                    const hue = Math.min(energy * 10, 360);
                    ctx.fillStyle = \`hsl(\${hue}, 100%, 50%)\`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Border
                    ctx.strokeStyle = '#00a8ff';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText((entity.label || \`E\${idx}\`).substring(0, 6), x, y + 3);
                });
            }

            // Draw origin
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2 - 10, canvas.height / 2);
            ctx.lineTo(canvas.width / 2 + 10, canvas.height / 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, canvas.height / 2 - 10);
            ctx.lineTo(canvas.width / 2, canvas.height / 2 + 10);
            ctx.stroke();
        }

        function resetCanvas() {
            // Resets view to origin
            logTerminal('Canvas view reset', 'output');
        }

        // ============================================
        // METRICS & ENTITIES
        // ============================================
        function updateMetrics() {
            if (!state.physicsState) {
                document.getElementById('frameCount').textContent = '0';
                document.getElementById('kineticEnergy').textContent = '0.0';
                document.getElementById('bodyCount').textContent = '0';
                document.getElementById('collisionCount').textContent = '0';
                return;
            }

            const ps = state.physicsState;
            document.getElementById('frameCount').textContent = ps.frame || 0;
            document.getElementById('kineticEnergy').textContent = (ps.kinetic_energy || 0).toFixed(2);
            document.getElementById('bodyCount').textContent = ps.bodies_count || 0;
            document.getElementById('collisionCount').textContent = ps.collision_count || 0;
            document.getElementById('simTime').textContent = ((ps.elapsed_time || 0) / 1000).toFixed(2);

            // FPS calculation
            const now = Date.now();
            const delta = now - state.lastFrameTime;
            if (delta > 0) {
                state.fps = Math.round(1000 / delta);
                document.getElementById('fpsValue').textContent = state.fps;
            }
            state.lastFrameTime = now;

            // Physics status
            if (state.apiConnected) {
                document.getElementById('physicsState').textContent = \`Online (Frame \${ps.frame})\`;
            }
        }

        function updateEntitiesList() {
            const container = document.getElementById('entitiesList');
            if (!state.entities || state.entities.length === 0) {
                container.innerHTML = '<p style="color: #666;">No active entities</p>';
                return;
            }

            container.innerHTML = state.entities.map((e, i) => \`
                <div class="entity-item" onclick="selectEntity(\${i})">
                    <div class="entity-label">\${e.label || \`Entity \${i}\`}</div>
                    <div class="entity-value">Pos: [\${(e.position[0] || 0).toFixed(2)}, \${(e.position[1] || 0).toFixed(2)}, \${(e.position[2] || 0).toFixed(2)}]</div>
                    <div class="entity-value">KE: \${(e.kinetic_energy || 0).toFixed(2)} J</div>
                    <div class="entity-value">Mass: \${(e.mass || 1).toFixed(2)} kg</div>
                </div>
            \`).join('');
        }

        function selectEntity(idx) {
            state.selectedEntity = idx;
            logTerminal(\`Selected entity: \${state.entities[idx].label}\`, 'output');
        }

        // ============================================
        // PROPHECY SYSTEM
        // ============================================
        async function applyProphecy() {
            const input = document.getElementById('prophecyInput');
            const prophecy = input.value.trim();

            if (!prophecy) {
                logTerminal('No prophecy specified', 'error');
                return;
            }

            if (!state.apiConnected) {
                logTerminal('API not connected', 'error');
                return;
            }

            try {
                const response = await fetch(\`\${API_URL}/prophecy/apply_physics\`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prophecy })
                });

                if (response.ok) {
                    const result = await response.json();
                    state.prophecyLog.push(\`\${new Date().toLocaleTimeString()}: \${prophecy}\`);
                    updateProphecyLog();
                    logTerminal(\`Prophecy applied: \${prophecy}\`, 'output');
                    input.value = '';
                } else {
                    logTerminal('Prophecy failed', 'error');
                }
            } catch (e) {
                logTerminal(\`Prophecy error: \${e.message}\`, 'error');
            }
        }

        function updateProphecyLog() {
            const log = document.getElementById('prophecyLog');
            log.innerHTML = state.prophecyLog.map(entry => 
                \`<div style="margin-bottom: 4px; color: #888;">\${entry}</div>\`
            ).join('');
        }

        // ============================================
        // GEOMETRY & AESTHETICS
        // ============================================
        function generateSurfaceNets() {
            if (!state.entities || state.entities.length === 0) {
                logTerminal('No entities to generate mesh from', 'error');
                return;
            }

            document.getElementById('geometryStatus').innerHTML = '<p style="color: #0f0;">Generating mesh...</p>';
            logTerminal(\`Generating surface mesh for \${state.entities.length} entities\`, 'output');

            // Simulate mesh generation
            setTimeout(() => {
                document.getElementById('geometryStatus').innerHTML = '<p style="color: #0f0;">Mesh generated (\${state.entities.length * 100} triangles)</p>';
                logTerminal('Surface mesh generated', 'output');
            }, 500);
        }

        function updateAesthetics() {
            if (!state.physicsState) {
                logTerminal('No physics state available', 'error');
                return;
            }

            document.getElementById('aestheticsStatus').innerHTML = '<p style="color: #0f0;">Updating aesthetics...</p>';
            logTerminal('Updating aesthetic feedback from physics state', 'output');

            setTimeout(() => {
                document.getElementById('aestheticsStatus').innerHTML = '<p style="color: #0f0;">Aesthetics updated</p>';
            }, 300);
        }

        // ============================================
        // TERMINAL
        // ============================================
        function handleTerminalInput(event) {
            if (event.key !== 'Enter') return;

            const input = document.getElementById('terminalInput');
            const command = input.value.trim();
            input.value = '';

            if (!command) return;

            logTerminal(command, 'prompt');

            // Parse command
            const parts = command.split(' ');
            const cmd = parts[0];

            switch (cmd) {
                case 'physics:spawn':
                    const [x, y, z] = parts.slice(1, 4).map(parseFloat);
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        spawnPhysicsBody();
                    } else {
                        logTerminal('Usage: physics:spawn <x> <y> <z>', 'error');
                    }
                    break;
                case 'physics:step':
                    stepPhysics();
                    break;
                case 'physics:reset':
                    resetPhysics();
                    break;
                case 'physics:state':
                    if (state.physicsState) {
                        logTerminal(\`Frame: \${state.physicsState.frame}, KE: \${state.physicsState.kinetic_energy.toFixed(2)}J, Bodies: \${state.physicsState.bodies_count}\`, 'output');
                    } else {
                        logTerminal('Physics not available', 'error');
                    }
                    break;
                case 'help':
                    logTerminal('Available commands: physics:spawn, physics:step, physics:reset, physics:state, help, clear', 'output');
                    break;
                case 'clear':
                    document.getElementById('terminal').innerHTML = '';
                    break;
                default:
                    logTerminal(\`Unknown command: \${cmd}\`, 'error');
            }
        }

        function logTerminal(message, type = 'output') {
            const terminal = document.getElementById('terminal');
            const line = document.createElement('div');
            line.className = 'terminal-line';

            if (type === 'prompt') {
                line.innerHTML = \`<span class="terminal-prompt">> \${message}</span>\`;
            } else if (type === 'error') {
                line.innerHTML = \`<span class="terminal-error">‚úó \${message}</span>\`;
            } else {
                line.innerHTML = \`<span class="terminal-output">\${message}</span>\`;
            }

            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function showAbout() {
            alert('World Engine Studio v1.0\\n\\n‚öôÔ∏è Integrated Physics Simulation\\nüé® Node Graph Visualization\\nüíª Terminal Shell\\nüîÆ Keeper Nexus Prophecy System\\n\\nBuilt with FastAPI + React\\nPowered by NexusCore Physics');
        }
    </script>
</body>
</html>
