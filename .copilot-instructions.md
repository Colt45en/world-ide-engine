# Copilot Instructions: World Engine Development Guide

## Overview

This file provides guidelines and best practices for Copilot (and human developers) working on the World Engine IDE project. The World Engine is a high-performance, data-oriented system designed for semantic analysis, procedural generation, and large-scale world simulation.

## 1. Architecture Principles

### 1.1 Data-Oriented Design (DoD)

- **Prioritize memory layout**: Structure code around SoA (Structure of Arrays) patterns, not AoS (Array of Structures).
- **Cache coherency**: Keep frequently-accessed data contiguous in memory. Avoid scattered access patterns.
- **Example**: 
  ```python
  # âŒ Bad: AoS - mixes unrelated data
  class Entity:
      position: Vector3
      velocity: Vector3
      color: Color
      ai_state: AIState
  
  # âœ… Good: SoA - separate arrays for each component
  class Positions: 
      data: List[Vector3]
  class Velocities: 
      data: List[Vector3]
  ```

### 1.2 Entity Component System (ECS)

- Use archetype-based ECS for hot-path simulation (core runtime).
- Batch structural changes (Add/Remove components) at frame boundaries via **Command Buffers**.
- Avoid deep component hierarchies; prefer flat, composable components.
- **Example pattern**:
  ```python
  # Query for entities with specific components
  entities = world.query([Position, Velocity, Renderable])
  for entity in entities:
      pos = world.get_component(entity, Position)
      vel = world.get_component(entity, Velocity)
      # Update logic here
  ```

### 1.3 Modular Decoupling

- Systems communicate through **data contracts** (well-defined input/output interfaces), not tight coupling.
- Physics, rendering, scripting, and PCG modules should be independent; integrate via APIs.
- Avoid circular dependencies and runtime dynamic imports unless absolutely necessary.

## 2. Python Project Structure & Standards

### 2.1 Directory Layout

```
/engine            - Core runtime modules (ECS, physics, world streaming)
/graphics          - Rendering, shaders, materials (RDG patterns)
/ai                - AI, semantic analysis, NLP (spaCy, transformers)
/scales            - Scaling systems, seeds, constraints (data management)
/context           - Parsing, text analysis, knowledge extraction
/math              - Math library, linear algebra, geometry
/db                - Database, migrations, persistence layer
/api               - REST API, endpoints, service layer
/web               - Frontend UI (studio, editor, playtest views)
/tests             - Unit and integration tests
/tools             - Build scripts, asset cookers, CLI utilities
```

### 2.2 Naming Conventions

- **Modules**: `lowercase_with_underscores` (e.g., `seed_manager.py`)
- **Classes**: `PascalCase` (e.g., `SeedManager`, `WorldStreamer`)
- **Functions/Methods**: `lowercase_with_underscores` (e.g., `get_entity`, `apply_constraint`)
- **Constants**: `UPPERCASE_WITH_UNDERSCORES` (e.g., `CHUNK_SIZE`, `MAX_ENTITIES`)
- **Private members**: Prefix with `_` (e.g., `_internal_cache`)

### 2.3 Type Hints & Documentation

- Always include type hints on public API functions.
- Use docstrings (Google style) for classes and complex functions.
- Document **why**, not just **what** (especially for performance-critical code).

### 2.4 Code Organization

- **One class/interface per file** (unless very tightly coupled).
- **Group related functions** into modules.
- **Avoid module-level mutable state**; use dependency injection.

## 3. Core Systems: Implementation Patterns

### 3.1 Seeds & Constraints

- **SeedManager**: Centralized hub for managing seeds, constraints, and validation.
- **Persistence**: Support both JSON (development) and SQLite (production).
- **API**: Provide CRUD endpoints (`/api/seeds`, `/api/constraints`).
- **Validation**: Enforce constraint rules at write time; fail fast with clear error messages.

### 3.2 Parser & NLP

- Use **spaCy** for tokenization, POS tagging, named entity recognition.
- Cache spaCy models at module init; avoid reloading per-call.
- Expose high-level APIs: `parse()`, `extract_keywords()`, `analyze_sentiment()`.

### 3.3 FastAPI Service Layer

- All endpoints must include request/response validation via **Pydantic models**.
- Return consistent error responses: `{ "error": "...", "details": "..." }`.
- Use **dependency injection** for shared resources.
- Implement **graceful shutdown**: close DB connections on app close.

### 3.4 Database & Migrations

- **WAL Mode**: Always enable SQLite WAL for concurrent reads/writes.
- **Migrations**: Place SQL scripts in `db/migrations/` named `000_description.sql`, etc.
- **Idempotency**: Migrations must be safe to run multiple times.

### 3.5 Web UI

- Use **vanilla HTML/CSS/JS** for lightweight, cacheable UIs.
- Implement a **message bridge** for component communication.
- Controllers expose methods callable from the UI.
- Avoid heavy client-side frameworks unless necessary.

## 4. Testing & Quality Standards

### 4.1 Testing Requirements

- **Unit tests**: Test individual modules in isolation.
- **Integration tests**: Test API endpoints, DB persistence, multi-system interactions.
- **Deterministic tests**: Use fixed seeds and compare golden outputs.
- **Coverage goal**: >75% on core modules.

### 4.2 Running Tests Locally

```bash
python -m pytest tests/ -v
python -m pytest tests/ --cov=engine --cov=scales --cov=context --cov=api
```

### 4.3 CI/CD Expectations

- GitHub Actions runs on all PRs: Python 3.11, 3.12, 3.13.
- Coverage uploaded to Codecov; threshold enforced at 75%.
- All tests must pass before merge.

## 5. Git Workflow & PR Standards

### 5.1 Branch Naming

- Feature branches: `feat/short-description`
- Bug fixes: `fix/short-description`
- Docs: `docs/short-description`
- Refactor: `refactor/short-description`

### 5.2 Commit Messages

Follow **Conventional Commits**:
```
<type>(<scope>): <subject>

<body>

<footer>
```

### 5.3 Pull Request Checklist

- âœ… All tests pass locally
- âœ… Code follows naming/style conventions
- âœ… Type hints added to public APIs
- âœ… Docstrings updated
- âœ… New features have tests
- âœ… No debug prints or temporary code
- âœ… PR title follows format: `type(scope): description`

## 6. Common Tasks & Patterns

### 6.1 Adding a New API Endpoint

1. Define Pydantic models in `api/models.py`.
2. Implement handler in `api/service.py`.
3. Add unit tests in `tests/test_api.py`.
4. Document in `docs/API.md`.
5. Commit: `feat(api): add <endpoint> endpoint`.

### 6.2 Adding a New Component Type (ECS)

1. Define component in `engine/components.py`.
2. Add logic to relevant system.
3. Add archetype queries.
4. Write tests.
5. Update `docs/ARCHITECTURE.md` if major.

### 6.3 Extending the Parser (NLP)

1. Add method to `TextParser` in `context/parser.py`.
2. Use spaCy pipeline features.
3. Write tests in `tests/test_parser.py`.
4. Expose via API if user-facing.

### 6.4 Adding a New Constraint Type

1. Define validation logic in `SeedManager`.
2. Add API endpoint.
3. Persist to DB.
4. Write integration tests.
5. Document in `docs/CONSTRAINTS.md`.

## 7. Performance & Optimization Guidelines

### 7.1 Hot Paths

- Minimize allocations; reuse buffers.
- Avoid unnecessary function calls in loops.
- Use type hints for potential JIT compilation.
- Profile before optimizing.

### 7.2 Database Queries

- Use batch operations.
- Maintain indices on frequently-queried columns.
- Use connection pooling in production.

### 7.3 API Response Times

- Cache expensive computations.
- Stream large responses if applicable.
- Set reasonable timeout limits.

## 8. Error Handling & Logging

### 8.1 Error Handling Patterns

- **Fail fast**: Validate inputs early.
- **Graceful degradation**: Log and continue if safe.
- **Error codes**: Use HTTP status codes consistently.

### 8.2 Logging

- Use Python''s `logging` module.
- Levels: DEBUG, INFO, WARNING, ERROR.
- Include context in log messages.

## 9. Documentation Standards

### 9.1 Code Documentation

- Docstrings for all public classes and methods.
- Type hints on function signatures.
- Complex algorithms: explain with high-level comments.

### 9.2 Project Documentation

- **README.md**: Quick start, running, key features.
- **docs/ARCHITECTURE.md**: System design, module layout.
- **docs/API.md**: REST API endpoints.
- **docs/CONSTRAINTS.md**: Constraint types.
- **docs/DEVELOPMENT.md**: Setup, contributing.

### 9.3 Inline Documentation

- Prefer clear code over comments.
- Comments explain *why*, not *what*.
- Update docs when changing behavior.

## 10. Deployment & Configuration

### 10.1 Environment Variables

- Use `.env.example` to document variables.
- Never commit `.env` files with secrets.
- Load via `python-dotenv`.

### 10.2 Docker (if applicable)

- Lightweight base images.
- Multi-stage builds.
- Document in `Dockerfile` and `docker-compose.yml`.

## 11. Troubleshooting & Debugging

### 11.1 Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| `ModuleNotFoundError` | Venv not active or package missing | Activate venv; `pip install -r requirements.txt` |
| Import cycles | Module A imports B, B imports A | Extract common code into third module |
| Tests fail locally but pass on CI | Version mismatch | Check Python version; compare venv |
| Database locked | Concurrent writes without WAL | Enable WAL: `PRAGMA journal_mode=WAL` |
| Slow API responses | Missing indices or N+1 queries | Profile with `cProfile`; add indices |

### 11.2 Debugging Tools

- **pdb**: `import pdb; pdb.set_trace()`.
- **logging**: Set `LOG_LEVEL=DEBUG`.
- **pytest**: Use fixtures to isolate tests.
- **git blame**: `git blame file.py`.

## 12. Future Enhancements & Roadmap

### 12.1 Planned Modules

- **Procedural Content Generation**: Wave Function Collapse, noise-based generation.
- **Job System**: Parallel task scheduling.
- **World Streaming**: Chunk loading/unloading.
- **Scripting Layer**: Lua/Python VM.
- **Editor Tools**: IMGUI-based editor.

### 12.2 Guidelines for New Features

- Consult `docs/ARCHITECTURE.md` for design patterns.
- Follow "modular decoupling" principle.
- Add tests and documentation from day one.
- Request review in PR.

---

## Summary

The World Engine is built on **Data-Oriented Design**, **modular ECS**, and **robust testing**. Follow these guidelines to write efficient, loosely-coupled, well-tested code.

**Happy coding!** ðŸš€
